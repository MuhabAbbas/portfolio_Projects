-- Olist Dataset
-- 1: What is the total revenue generated by Olist, and how has it changed over time?
--Total revenue:
SELECT ROUND(SUM(payment_value),2) as total_revenue
FROM [dbo].[olist_order_payments_dataset] as payments
INNER JOIN [dbo].[olist_orders_dataset] as orders
ON 
orders.order_id = payments.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31';

-- Total revenue over time:
SELECT order_date,ROUND(SUM(payment_value),2) as total_revenue
FROM [dbo].[olist_order_payments_dataset] as payments
INNER JOIN [dbo].[olist_orders_dataset] as orders
ON
orders.order_id = payments.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY order_date
ORDER BY order_date;

-- 2: How many orders were placed on Olist, and how does this vary by month or season?
--Number of orders placed:
SELECT COUNT(order_date) as No_of_orders
FROM [dbo].[olist_orders_dataset]
WHERE order_status != 'canceled' and order_status != 'unavailable' and order_date >= '2017-01-01' 
and order_date <= '2018-08-31';

-- Seasonal & monthly orders?
SELECT order_date, COUNT(order_id) as No_of_orders
FROM [dbo].[olist_orders_dataset]
WHERE order_status != 'canceled' and order_status != 'unavailable' and order_date >= '2017-01-01' 
and order_date <= '2018-08-31'
GROUP BY order_date 
ORDER BY order_date;

-- 3: What are the most popular product categories on Olist, and how do their sales volumes compare to each other?
--Most popular product categories on Olist
WITH products1 as(
SELECT order_id, items.product_id, english.product_category_name_english as category_name
FROM [Olist].[dbo].[olist_order_items_dataset] as items
INNER JOIN [dbo].[olist_products_dataset] as products
ON
items.product_id = products.["product_id"]
INNER JOIN [dbo].[product_category_name_translation] as english
ON
products.["product_category_name"] = english.product_category_name)
SELECT category_name, COUNT(product_id) as products_sold
FROM products1
LEFT JOIN olist_orders_dataset as orders
ON
products1.order_id = orders.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'
GROUP BY category_name
ORDER BY products_sold DESC;

--4: What is the average order value (AOV) on Olist, and how does this vary by product category or payment method?
--AOV
SELECT avg(payment_value) as AOV
FROM [dbo].[olist_order_payments_dataset] as payments
INNER JOIN [dbo].[olist_orders_dataset] as orders
ON 
orders.order_id = payments.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31';

-- AOV by product_category:
SELECT english.product_category_name_english as category, ROUND(AVG(payment_value),2) as AOV
FROM [dbo].[olist_order_payments_dataset] as payments
INNER JOIN [dbo].[olist_orders_dataset] as orders
ON 
orders.order_id = payments.order_id
INNER JOIN [Olist].[dbo].[olist_order_items_dataset] as items
ON 
orders.order_id = items.order_id
INNER JOIN [dbo].[olist_products_dataset] as products
ON
items.product_id = products.["product_id"]
INNER JOIN [dbo].[product_category_name_translation] as english
ON
products.["product_category_name"]=english.product_category_name
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY english.product_category_name_english
ORDER BY 2 DESC;

-- AOV by payment method:
SELECT payment_type as payment_method, ROUND(AVG(payment_value),2) as AOV
FROM [dbo].[olist_order_payments_dataset] payments
INNER JOIN [dbo].[olist_orders_dataset] as orders
ON 
orders.order_id = payments.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY payment_type
ORDER BY AOV DESC;

-- 5: How many sellers are active on Olist, and how does this number change over time?
--Active sellers:
WITH cte as(
SELECT sellers.seller_id as active_sellers, COUNT(DISTINCT orders.order_id) as no_of_orders
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_order_items_dataset] as items
ON
orders.order_id = items.order_id
INNER JOIN [dbo].[olist_sellers_dataset] as sellers
ON
sellers.seller_id = items.seller_id
INNER JOIN [dbo].[olist_order_reviews_dataset] as reviews
ON
orders.order_id = reviews.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY sellers.seller_id
HAVING DATEDIFF(DAY, MIN(order_date), MAX(order_date)) >= 90 and COUNT(items.product_id) > 10 and
       COUNT(DISTINCT orders.order_id) >= 1 and AVG(review_score) >= 4)
SELECT COUNT(*) as active_sellers
FROM cte;

--Active sellers by year:
WITH cte as(
SELECT YEAR(order_date) as active_year , sellers.seller_id as active_sellers, COUNT(DISTINCT orders.order_id) as no_of_orders
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_order_reviews_dataset] as reviews
ON
orders.order_id = reviews.order_id
INNER JOIN [dbo].[olist_order_items_dataset] as items
ON
orders.order_id = items.order_id
INNER JOIN [dbo].[olist_sellers_dataset] as sellers
ON
sellers.seller_id = items.seller_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY YEAR(order_date), sellers.seller_id
HAVING DATEDIFF(DAY, MIN(order_date), MAX(order_date)) >= 90 and COUNT(items.product_id) > 10 and
       COUNT(DISTINCT orders.order_id) >= 1 and AVG(review_score) >= 4)
SELECT active_year, COUNT(*) as active_sellers
FROM cte
GROUP BY active_year;

-- 6: What is the distribution of seller ratings on Olist, and how does this impact sales performance?
-- Distribution of seller ratings:
WITH cte1 as(
SELECT seller_id, review_score
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_order_reviews_dataset] as reviews
ON
orders.order_id = reviews.order_id
INNER JOIN [dbo].[olist_order_items_dataset] as items
ON
orders.order_id = items.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'),
cte2 as(
SELECT review_score, COUNT(seller_id) as sellers
FROM cte1
GROUP BY review_score)
SELECT *, CASE WHEN review_score = 5 THEN '5 Stars'
			   WHEN review_score = 4 THEN '4 Stars'
			   WHEN review_score = 3 THEN '3 Stars'
			   WHEN review_score = 2 THEN '2 Stars'
			   ELSE '1 Star' END as review_score
FROM cte2
ORDER BY 1 DESC;

-- 7: How many customers have made repeat purchases on Olist, and what percentage of total sales do they account for?
-- The number of customers who made a repeated purchase:
WITH customer1 as(
SELECT customer_unique_id,orders.order_id, 
RANK()over(partition by customers.customer_unique_id order by orders.order_id) as ranks
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_customers_dataset] as customers
ON
orders.customer_id = customers.customer_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'),
customer2 as(
SELECT *
FROM customer1
WHERE ranks > 1)
SELECT COUNT(DISTINCT customer_unique_id) as repeated_purchases_customers
FROM customer2;

-- Percentage of Sales:
WITH repeated_customers as(
SELECT customers.customer_unique_id,orders.order_id, SUM(payment_value) as revenue
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_customers_dataset] as customers
ON
orders.customer_id = customers.customer_id
INNER JOIN [dbo].[olist_order_payments_dataset] AS payments
ON
orders.order_id = payments.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY orders.order_id, customers.customer_unique_id),
repeated_customers2 as(
SELECT customer_unique_id, revenue
FROM repeated_customers),
percentages as(
SELECT *, CASE WHEN customer_unique_id = repeated_purchases_customers THEN revenue ELSE 0 END as repeated_purchases_revenue
FROM repeated_customers2 as a
LEFT JOIN rps as b
ON
a.customer_unique_id = b.repeated_purchases_customers)
SELECT ROUND(100 * (SUM( repeated_purchases_revenue)/SUM(revenue)),2) as percentage
FROM percentages;

-- 8: What is the average customer rating for products sold on Olist, and how does this impact sales performance?
-- Average customer rating
with cte as(
SELECT product_id, review_score
FROM [dbo].[olist_order_reviews_dataset] as reviews
INNER JOIN [dbo].[olist_orders_dataset] as orders
ON
orders.order_id = reviews.order_id
INNER JOIN [dbo].[olist_order_items_dataset] as items
ON
orders.order_id = items.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31')
SELECT ROUND(CAST(AVG(review_score) AS float),2) as avg_rating
FROM cte;

-- 9: What is the average order cancellation rate on Olist, and how does this impact seller performance?
-- Avg order cancellation rate:
SELECT ROUND(SUM(CASE WHEN order_status = 'canceled' then 1 ELSE 0 END)/CAST(COUNT(DISTINCT order_id) AS float)* 100, 2) as cancelation_rate
FROM [dbo].[olist_orders_dataset]
WHERE order_date >= '2017-01-01' and order_date <= '2018-08-31';

-- 10: What are the top-selling products on Olist, and how have their sales trends changed over time?
--Top selling products:
SELECT english.product_category_name_english as category_name, COUNT(products.["product_id"]) as products_sold
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [Olist].[dbo].[olist_order_items_dataset] as items
ON
orders.order_id = items.order_id
INNER JOIN [dbo].[olist_products_dataset] as products
ON
items.product_id = products.["product_id"]
INNER JOIN [dbo].[product_category_name_translation] as english
ON
products.["product_category_name"] = english.product_category_name
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY english.product_category_name_english
ORDER BY products_sold DESC;

-- Top selling products over time:
SELECT english.product_category_name_english as category_name, order_date, COUNT(products.["product_id"]) as products_sold
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [Olist].[dbo].[olist_order_items_dataset] as items
ON
orders.order_id = items.order_id
INNER JOIN [dbo].[olist_products_dataset] as products
ON
items.product_id = products.["product_id"]
INNER JOIN [dbo].[product_category_name_translation] as english
ON
products.["product_category_name"] = english.product_category_name
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
order_date >= '2017-01-01' and order_date <= '2018-08-31'
GROUP BY english.product_category_name_english, order_date
ORDER BY order_date, products_sold DESC;

-- 11: Which payment methods are most commonly used by Olist customers, and how does this vary by product category or geographic region?
-- The most payment method used by customers:
SELECT payment_type as payment_method, count(payment_type) as No_of_times_used
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_customers_dataset] as customers
ON
orders.customer_id = customers.customer_id
INNER JOIN [dbo].[olist_order_payments_dataset] as payments
ON
orders.order_id = payments.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'
GROUP BY payment_type
ORDER BY No_of_times_used DESC;

-- By category:
SELECT eng.product_category_name_english as category, payment_type as payment_method, COUNT(payment_type) as No_of_times_used
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_customers_dataset] as customers
ON
orders.customer_id = customers.customer_id
INNER JOIN [dbo].[olist_order_payments_dataset] as payments
ON
orders.order_id = payments.order_id
INNER JOIN [dbo].[olist_order_items_dataset] items
ON
items.order_id = orders.order_id
INNER JOIN [dbo].[olist_products_dataset] products
ON 
items.product_id = products.["product_id"]
INNER JOIN [dbo].[product_category_name_translation] as eng
ON
products.["product_category_name"] = eng.product_category_name
INNER JOIN [dbo].[regions] as regions
ON
customers.customer_state = regions.state
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'
GROUP BY payment_type, eng.product_category_name_english
ORDER BY payment_method, No_of_times_used DESC;

-- By geographic location:
SELECT region, payment_type as payment_method, COUNT(payment_type) as No_of_times_uesed
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_customers_dataset] as customers
ON
orders.customer_id = customers.customer_id
INNER JOIN [dbo].[olist_order_payments_dataset] as payments
ON
orders.order_id = payments.order_id
INNER JOIN [dbo].[olist_order_items_dataset] items
ON
items.order_id = orders.order_id
INNER JOIN [dbo].[olist_products_dataset] products
ON 
items.product_id = products.["product_id"]
INNER JOIN [dbo].[product_category_name_translation] as eng
ON
products.["product_category_name"] = eng.product_category_name
INNER JOIN [dbo].[regions] as regions
ON
customers.customer_state = regions.state
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'
GROUP BY payment_type, region
ORDER BY payment_method, No_of_times_uesed DESC;

-- 13: Which product categories have the highest profit margins on Olist, and how can the company increase profitability across different categories?
--Profit margin by category
SELECT eng.product_category_name_english as category, 
ROUND((SUM(payment_value) - SUM(price + freight_value)) / SUM(payment_value)*100,2) as profit_margin
FROM [dbo].[olist_order_items_dataset] as items
INNER JOIN [dbo].[olist_order_payments_dataset] as payments
ON
items.order_id = payments.order_id
INNER JOIN [dbo].[olist_products_dataset] as products
ON
items.product_id = products.["product_id"]
INNER JOIN [dbo].[product_category_name_translation] as eng
ON
products.["product_category_name"] = eng.product_category_name
INNER JOIN [dbo].[olist_orders_dataset] as orders
ON
orders.order_id = items.order_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'
GROUP BY eng.product_category_name_english
ORDER BY profit_margin DESC;

-- 15: Geolocation having high customer density. Calculate customer retention rate according to geolocations.
-- Customer density:
WITH density1 as(
SELECT customer_state, customer_unique_id,orders.order_id, order_date, 
RANK()over(partition by customers.customer_unique_id order by orders.order_id) as ranks
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_customers_dataset] as customers
ON
orders.customer_id = customers.customer_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'),
density2 as(
SELECT *
FROM density1
WHERE ranks = 1)
SELECT customer_state, region, COUNT(customer_unique_id) as total_customers
FROM density2
INNER JOIN [dbo].[regions]
ON
density2.customer_state = regions.state
GROUP BY customer_state, region
ORDER BY total_customers DESC;

-- Cuatomer retention rate:
WITH retention1 as(
SELECT customer_state, customer_unique_id,orders.order_id, order_date, 
RANK()OVER(PARTITION BY customers.customer_unique_id ORDER BY orders.order_id) as ranks
FROM [dbo].[olist_orders_dataset] as orders
INNER JOIN [dbo].[olist_customers_dataset] as customers
ON
orders.customer_id = customers.customer_id
WHERE orders.order_status != 'canceled' and orders.order_status != 'unavailable' and
orders.order_date >= '2017-01-01' and orders.order_date <= '2018-08-31'),
retention2 as(
SELECT *, CASE WHEN ranks = 1 THEN 1 ELSE 0 END as total_customers, CASE WHEN ranks = 2 THEN 1 ELSE 0 END as customer_retention
FROM retention1),
retention3 as(
SELECT customer_state, SUM(total_customers) as total_customers, SUM(customer_retention) as customer_retention
FROM retention2
GROUP BY customer_state)
SELECT customer_state, region, ROUND(CAST(customer_retention as float) / CAST(total_customers as float) * 100,2) as customer_retention_rate
FROM retention3
INNER JOIN [dbo].[regions] 
ON
retention3.customer_state = regions.state
ORDER BY 1;
